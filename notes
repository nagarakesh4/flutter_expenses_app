widgets/styling/adding logic
Layout widgets:
    Row: take multiple children
        flexible widget
        expanded widget
        
    Column : take multiple children
        flexible widget
        expanded widget

    Container

Content container:
    Stack: items on top of each other (image with text in foreground)
    Card: prestyled container (padding/boxshadow) - with default styles

Repeating content:
    List View:
        List Tile: 
    Grid View:

Content Types:
    Icon
    text
    image

User Input
    text field
    raised button

Hidden widget:
    inkwell (tap, doubletap)
    gesture


70. Add scaffolding new flutter project

    1. add column widget in body, with two children containing card widgets for chart of expense and list of transactions
    2. card by default assumes the size of its children, so change the size of child, so change size of text which means change size of its parent, to break this dependency, there are 2 ways:
        - use Container wrap on top of card child and set its width to 100, there by the card will no longer rely on the size of text but will rely on size of container with space as double.infinitly  (take as much as width as it can)
        - instead of wrapping the child of card with container, wrap the card itself with container and it is same as the previous one. the implication however is the card by default depends on its child (text) unless there is a parent (container) with a container, 
            but this option doesn't work with column, column always depends on its children (the broadest width), card however takes its parent as the measurement

71.
    3. column has crossAxisAlignment (left to right), default is top to bottom (mainAxisAlignment)
        mainAxisAlignment.center (default is start) - is like flex-end etc.., similar to flex the other options are available (spacebetween etc)
        crossAxisAlignment: CrossAxisAlignment.end, will move the element on left to right to right most
        using this the card now follows the parent width which is set by 'column' widget usign the above axis alignments
    4. in row it is the opposite of above

Jot:
    Rows and Columns are used to organize multiple sibling widgets. (can have more than one child widget)
    By default Columns take all the height space they can get.
    you can absolutely have a Row in a Column, a Column in a Row or Rows in Rows / Columns in Columns.


72.
    5. for the app, we need to add 'transactions'. create a map to store the list of transactions
    6. store the transaction as a separate blueprint (transaction.dart) doesnt extend stateless/stateful, and not needed to extend Widget 
    7. it takes variables requeired and a named argument constructor
    8. add required annotation from foundation.dart
    9. in main.dart create a list entry to store these transactions
    10. create a column for loading transactions in main.dart , take transaction list and create a map of it. instead of an explicit widgets, create a list of widgets
    11. .map returns an iterable so we need to explicitly convert into a list using .toList (see notes1 for more)

74.
    12. transaction should be shown as  card, with two rows and the second row having two columns, and each of the row element is in a container

75.
    13. no separate styling lang, we style widgets through arguments, so in case  if a widget doesn't have styling to it (ex: text), we need to leverage other widgets (create new or its parent)
    14. always create margin using EdgetInsets. - margin in all direction, 'only' to specify separately, symmetric
    15. to style the appearance of container, using decoration property that uses boxdecoration widget(not every widget will have it)
        and inside boxdecoration widget it takes in border color, width etc
        similarly padding takes EdgetInsets and can use .all(10) - to have padding of 10 on all sides
76. 16. text styling
    text will have style property and can use TextStyle widget to style the text and inside it use fontWeight property with FontWeight.bold, FontWeight is class with prop, static props are basically enums but with labels (instead of numbers)
    and similarly font size, and the container will grow with the content

77.
    set crossAxisAlignment to left for title and date
    adjust text style properties

Jot:
    you configure widgets via their constructor arguments - that includes styling config.
    Container has 'decoration' argument that uses BoxDecoration() and creates a decoration object which you can configure in many different ways (e.g. border, radius, color) via its constructor arguments.

78.
    Container: 
        takes only one widget as children
        allows to add padding, decoration, border, color, padding, 
        flexible width: by default takes child width, but also takes parent width if one, also set width on the container - order exists
        perfect for custom styling and alignment
    Column/Row:
        takes multiple children as widgets
        allows CrossAxisAlignment and mainAxisAlignment but that's it no styling options
        Column takes full available height
        Row takes full available width
        must-use if widgets sit next to above/below
    can mix and match the above two

79.
    String interpolation:
        1. + works
        2. interpolate: '\$${tx.amount}'

80/81.
    Dates
    look for 'dart dateformat' - look for pub.dev - has packages that we can install in our dart project
    look for 'intl'
    add the dependency in pubspec.yaml under 'dependencies' section
    saving should get the package automatically, if not run flutter packages get - to get all packages downloaded
    source code the dependencies package (ex: node_modules) is not stored in the project folder but in /user folder, just a connection is established
    import 'package:intl/intl.dart';
    and use as DateFormat().format(tx.dateTime) - then stop and start the simulator for the package to be reflected
    to define custom patterns
        DateFormat('yyyy-mm-dd')
        or just call that pattern as DateFormat().add_yMMMd()

82.
    TextField: input text widget
    card has margin, but no padding
    column doesnt have margin, so wrap it with container
    and add padding inside container for adding padding 
    adding labels is possible on TextField, by using decoration argument with InputDecoration widget as:
    TextField(decoration: InputDecoration(labelText: 'Item Name'),),

83.
    fetching user input:
        either save it with every keystroke in a property 
        add variables titleInput
        add onChanged: on TextField, 
        onChanged: (value) => {
                      titleInput = value
                    },
        properties are not final, normally we can't have changeable properties in stateless widgets because obviously we can't update UI based on its changes anyways so can't use setState()

        in some cases, we are perfectly fine to change data without having any impact on UI then stateless works fine, if not
        
        - however flutter provides a controller way to get value of every keystroke change to final variables:
            final titleController = TextEditingController();
            TextEditingController - class by flutter , can be assigned to text fields using 'controller' argument
            these controllers will auto connect text fields to user input and saves the user input and 
            then use the above controller variable with '.text' to access the value
            TextField(
                decoration: InputDecoration(labelText: 'Item Price'),
                controller: itemAmountController,
                // onChanged: (value) => itemAmount = value,
            ),
            however this is just a temp solution to show that we can read value in stateless but still cannot update the state as setState will not work

    84.
        converting widget to stateful
        move transaction.dart into models/
        create widgets/ and add transaction_list.dart that loads transaction list
        initialize final transactionList 
        final List<Transaction> _userTransactions 
        move transactions listing code from main.dart to transaction_list.dart
        and do lifting state up - common denominator should be main.dart, so move the text input fields into a separate widget and thereby main.dart will stay stateless
        and hence appbar, scaffold will not be rebuilt when we add a new transaction
        move new transaction (input fields) to a stateless widget
        to avoid managing state in main.dart, create a user transactions widget and move new_transaction and transaction_list to it
        and make list transactions to stateless widget as we don't need to manage state there but instead manage state in user transactions widget
        and move the list of transactions in transaction_list.dart to _userTransactions.dart

    85.
        list transactions widget is a stateless widget implies it gets data from outside so create a constructor to receive the transactions
        pass the user transactions array from user_transaction.dart to list_transactions.dart
        create an addnewtransaction method in user_transaction.dart
        this method will recieve the new transaction details and are stored in final variable and not const, why?
        answer: because at the time of compiling the code (writing the src) we don't know the values this method recieves as transaction details, and hence not const but final
        the new transaction details final variable will create a new Transaction object with details
        to update this new transaction to the existing array, use setState and we can call as we are currently in user_transaction.dart which is a stateful widget
        also _userTransactions is a final variable which implies dart stores only objects in memory and only stores the pointers in the memory, so we can't change the memory change like _userTransactions = ... ..
        so we can just manipulate the object as _userTransactions.add(new_transaction)
        //add will only add the new element to the list but will not generate a new pointer
        _userTransactions.add(newTransaction);

    86.
        now new_transactions widget has a button that should invoke user_transactions widget addnewtransaction method and this can be done by passing the function reference to new_transaction widget
        and recieve the same in new_transaction widget as 
        
        final Function addNewTransaction;

        NewTransaction({this.addNewTransaction});

        double.parse(amount) - to parse to double value

        Adding new transaction is now working

    87. The problem we have now is scrollable. list of transactions will show error on UI w.r.t pixel overflow. 
        it is because the column takes full available height and row takes full available width, but not infinite amount by auto adding scrolls
        and each column will have their own height and at some point they can't shrink, child widgets won't fit anymore and we need to add scrolling
        add 'SingleChildScrollView' on the body element rather than on 'UserTransactions()' widget else it wont be able to find the container height in which it should scroll
        or either wrap column inside container widget and  then set an predefined height (based on device height) and set the SingleChildScrollView on top of it

    88. the other way to make column scroll is to create a list View
        list view is a column with SingleChildScrollView property, also there should be a height defined on its parent wrap because it doesn't assume any fixed height
        container(height: 300px, listview[]) - this is how listview should be used as, if we remove the wrapping container, no list is shown
        in the end list view is a widget that has infinite view, unlike a column which takes all of the available height on the given screen, 
        a list view can't have a fixed height because it is a scrollable element, therefore we need mention the height explictly for the items to be shown in listview
        now that wrapping it in a parent (container) and specify a height for parent, listview understands that there is aheight defined for its parent and then it uses that 
        height as its height
        Column + list view - column takes all the height it can get and list view has infinite height, this combination doesn't work
        Column + Container_height(list view) - the height is a critical thing, we cannot hardcode, have to set this by device height
        using a list view is better alternative and we also get other optimizations
